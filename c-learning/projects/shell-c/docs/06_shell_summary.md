# 🐚 C Shell 项目总结

恭喜！您已经成功构建了一个能运行的 Linux Shell。
这比 Grep 项目难度高了一个维度，因为它涉及到了**操作系统最核心的机制**。

## 🌟 核心成果
1.  **进程控制**: 使用 `fork` + `execvp` + `waitpid` 运行了外部程序。
2.  **内置命令**: 理解了为什么 `cd` 必须是 Shell 自己执行 (`chdir`)。
3.  **解析器**: 使用 `strtok` 手动实现了字符串切割。
4.  **安全环境**: 使用 `Podman/Docker` 容器进行隔离开发。

## 🧠 关键知识点

### 1. 为什么 `cd..` 报错？
您在测试时输入了 `cd..`（没空格），Shell 报错说找不到命令。
*   **原因**: 我们的 `strtok` 是按**空格**切分的。
*   `cd ..` -> `["cd", ".."]` -> Shell 识别出 `cd` 命令。
*   `cd..` -> `["cd.."]` -> Shell 以为可以在 `/bin` 目录下找到一个叫 `cd..` 的程序，当然找不到。

### 2. Fork 的哲学
*   Shell 不直接运行命令，而是先克隆一个自己，让替身去运行。
*   这就是为什么 Shell 即使运行了崩溃的程序，自己也不会挂掉。

---

## 🚀 存档
该项目代码已归档至 `c-learning-journey/code/shell/`。
您可以随时回顾这段代码，它是理解 Linux 进程管理的最佳范本。
