# ğŸ“ Network (ICPC 2005)

## ğŸ“Š é¢˜ç›®å…ƒä¿¡æ¯
- **éš¾åº¦ç­‰çº§**: â­â­â­â­â­â­ (ç»å…¸é¢˜ç›®)
- **å¹´ä»½**: 2005 ICPC
- **é€šè¿‡ç‡**: é«˜ (ç»å…¸ç½‘ç»œæµ)
- **æ ¸å¿ƒæŠ€æœ¯**: æœ€å¤§æµæœ€å°å‰²

---

## ğŸ¯ é—®é¢˜æè¿°

**ç»å…¸ç½‘ç»œæµé—®é¢˜**:
ç»™å‡ºä¸€ä¸ªæœ‰å‘å›¾ï¼Œæ¯æ¡è¾¹æœ‰å®¹é‡é™åˆ¶ï¼Œæ±‚ä»æºç‚¹åˆ°æ±‡ç‚¹çš„æœ€å¤§æµé‡ã€‚

### ğŸ“¥ è¾“å…¥è§„æ ¼
- å›¾çš„èŠ‚ç‚¹æ•°ã€è¾¹æ•°
- æ¯æ¡è¾¹çš„èµ·ç‚¹ã€ç»ˆç‚¹ã€å®¹é‡

### ğŸ“¤ è¾“å‡ºè§„æ ¼
- æœ€å¤§æµé‡å€¼

---

## ğŸ” éš¾ç‚¹å‰–æ

### ğŸš¨ ä¸‰å¤§æŒ‘æˆ˜
1. **å¢å¹¿è·¯å¾„å¯»æ‰¾**: å¦‚ä½•é«˜æ•ˆæ‰¾åˆ°å¢å¹¿è·¯å¾„
2. **æ®‹ä½™ç½‘ç»œç»´æŠ¤**: æ­£å‘è¾¹åå‘è¾¹çš„å®¹é‡æ›´æ–°
3. **ç®—æ³•æ”¶æ•›æ€§**: ç¡®ä¿ç®—æ³•åœ¨æœ‰é™æ­¥éª¤å†…ç»“æŸ

---

## ğŸ§  è§£é¢˜ç­–ç•¥

### ğŸ¯ æ€»ä½“æ€è·¯
**Dinicç®—æ³•: åˆ†å±‚å›¾ + å¤šè·¯å¢å¹¿**

### ğŸ“‹ è¯¦ç»†æ­¥éª¤

#### é˜¶æ®µ1: ç½‘ç»œå»ºæ¨¡
- å»ºç«‹æ®‹ä½™ç½‘ç»œ
- åˆå§‹åŒ–å®¹é‡

#### é˜¶æ®µ2: åˆ†å±‚å›¾æ„å»º
- BFSè®¡ç®—å„ç‚¹åˆ°æºç‚¹çš„è·ç¦»
- å»ºç«‹å±‚æ¬¡å›¾

#### é˜¶æ®µ3: å¢å¹¿è·¯å¾„æœç´¢
- DFSåœ¨å±‚æ¬¡å›¾ä¸­æ‰¾å¢å¹¿è·¯å¾„
- æ›´æ–°æ®‹ä½™å®¹é‡
- é‡å¤ç›´åˆ°æ— å¢å¹¿è·¯å¾„

---

## ğŸ’» å®ç°æ¡†æ¶

```c
#include <bits/stdc++.h>
using namespace std;

const int MAX_V = 205;
const int INF = 1e9;

struct Edge {
    int to, cap, rev;
};

vector<Edge> G[MAX_V];
int level[MAX_V];
int iter[MAX_V];

void add_edge(int from, int to, int cap) {
    G[from].push_back({to, cap, (int)G[to].size()});
    G[to].push_back({from, 0, (int)G[from].size() - 1});
}

void bfs(int s) {
    memset(level, -1, sizeof(level));
    queue<int> q;
    level[s] = 0;
    q.push(s);

    while(!q.empty()) {
        int v = q.front(); q.pop();
        for(auto& e : G[v]) {
            if(e.cap > 0 && level[e.to] < 0) {
                level[e.to] = level[v] + 1;
                q.push(e.to);
            }
        }
    }
}

int dfs(int v, int t, int f) {
    if(v == t) return f;
    for(int& i = iter[v]; i < G[v].size(); i++) {
        Edge& e = G[v][i];
        if(e.cap > 0 && level[v] < level[e.to]) {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d > 0) {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t) {
    int flow = 0;
    for(;;) {
        bfs(s);
        if(level[t] < 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s, t, INF)) > 0) {
            flow += f;
        }
    }
}

int main() {
    int V, E;
    cin >> V >> E;

    for(int i = 0; i < E; i++) {
        int u, v, c;
        cin >> u >> v >> c;
        add_edge(u, v, c);
    }

    cout << max_flow(0, V-1) << endl;
    return 0;
}
```

---

## ğŸ“š å­¦ä¹ è¦ç‚¹

### ğŸ¨ æŠ€æœ¯è¦ç‚¹
1. **æ®‹ä½™ç½‘ç»œ**: æ­£å‘åå‘è¾¹çš„å®¹é‡ç®¡ç†
2. **åˆ†å±‚å›¾**: BFSå»ºç«‹çš„å±‚æ¬¡ä¼˜åŒ–
3. **å¤šè·¯å¢å¹¿**: ä¸€æ¬¡DFSæ‰¾åˆ°å¤šæ¡è·¯å¾„

---

## ğŸ’¡ ç»ƒä¹ å»ºè®®

1. å®ç°åŸºç¡€çš„Ford-Fulkersonç®—æ³•
2. å­¦ä¹ Dinicç®—æ³•çš„åˆ†å±‚ä¼˜åŒ–
3. ç»ƒä¹ æ®‹ä½™ç½‘ç»œçš„å®¹é‡æ›´æ–°

---

**è¿™é“ç»å…¸é¢˜ç›®å¥ å®šäº†ç½‘ç»œæµåœ¨ç«èµ›ä¸­çš„åŸºç¡€åœ°ä½ï¼** ğŸ“